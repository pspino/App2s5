\documentclass[12pt]{article}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\usepackage{tikz}

\setlength{\parindent}{0cm}

\begin{document}
\begin{titlepage}
	\centering
	{\LARGE Jacob Fontaine \par
	 \LARGE Philippe Spino \par}
	\vspace{1cm}
	\small Spip2401\par
	\small Fonj1903\par 
	\vspace{3cm}
	{\Large Rapport App2\par}
	\vspace{5cm}
	{\Large Présente à :\par JEAN LAVOIE\par}
	\vspace{4cm}
	\vfill
% Bottom of the page
	{\large \today\par}
\end{titlepage}
\newpage
\tableofcontents
\pagenumbering{roman}
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}
\onehalfspacing
\setlength{\parskip}{1em}
\section{Introduction.}
Ce présent rapport a pour but de présenter les éléments de conception du système d'acquisition de données(SAD) développé par notre équipe. Le SAD a été conçue à l'aide d'un processeur embarqué LPC1768, soit la coquille de base du SAD. Le contenue de ce rapport explique les ressources mémoire et du processeur utilisées, les algorithmes de gestion des acquisitions, la synchronisation des tâches utilisées, une analyse des problèmes de conception et de déverminage lors du montage du prototype, une description des méthodes concernant la validation des fréquences d'échantillonnages des données et une analyse du prototype le plus optimal. De plus, une discusion sur les temps d'éxecution des codes base pour un inclinomètre. à la demande de la compagnie metrologie numérique.

\section{Utilisation des ressources matérielles.}
Pour ce présent prototype deux LCP1768 sont utilisés. Un des microcontrôleur est programmé pour emêttre de façon aléatoire des données soit numériquement ou bien analogiquement. Il est nommé DataSpammer. L'autre microcontrôleur utilise l'interface principale du SAD. Le DataSpammer, est réglé avec une fréquence d'opération mobile, c'est-à-dire qu'elle peut etre changé selon l'utilisateur. Pour le montage, nous avons 2 mbed qui sont branchés ensembles et le DataSpammer envoi ses données aléatoires via 2 port GPIO et la fréquence d'opératiopn passe de 10ms a 500ms. Sur le microcontrôleur qui a l'interface primaire, les led 1 et 2 servent a indiquer un changment de voltage sur les pattes analogiquer p19 et p20. Les led 3 et 4 servent a indiquer un événement numérique. Les pattes p21 et p22 sont utiliser.
\newpage
L'interface principale utilise 4 tâches pour faire la gestion des acquisitions, une tâche pour chaque type d'entrée, une tâche pour l'horloge temps-réel(RTC) et une tâche pour la gestion de la propagation. Pour propager les données acquisent, une structure, nommée Event, est utilisé. Cette structure contient un byte non signé, un entier de 32bit et une struct temporelle. Pour propager les Event, une file globale, qui contient des Event, de type First In First Out(FIFO) est utilisé. Pour la gestion de l'accès mémoire de cette file, un mutex global est utilisé. La file est utilisé par les deux tâches d'acqusitions numérique et analogique. Par la suite, pour l'acquisition du temps lors d'une capture de données, une file globale FIFO est utilisé pour une demande du temps. un mutex est aussi utilisé pour la gestion de l'accès a cette file. 

\section{Algorithmes de gestion des acquisitions de données.}
L'algorithme dévéloppé pour l'aquisition des données est divisé en 4 tâches différents. Numérique, Analogique et le RTC. La tâche pour l'acquisition numérique étant en priorisation haute, l'analogique en priorisation moyenne et le reste, soit la tâche pour le RTC, en priorisation basse.

\subsection{Numérique}
La tâche pour l'acqusition des données numérique vérifie s'il y a un changement de bit. Le temps pris pour qu'un bit puisse changer et être considéré un changement est de l'ordre des 50 ms. La fréquence d'opération de cet algorithme est 100ms. Pour ce faire, une tâche::wait est utilisé. cela permet d'être assuré que le tâche vas être à une fréquence de 100ms. Une boucle itérative sur 20 tours regarde les valeurs des pattes d'entrées digitales à toutes les 5ms, lorsque les valeurs rester inchangé après une itération, un conteur est incrémenté. Si dès que le conteur atteind 10(10 * 5ms = 50ms),l'algorithme a fait une demande au mutex pour assurer l'accès a la file et évité les interlockage. Ensuite, une réquisition du temps est fait à la tâche du RTC. Le mutex du temps est acquis et un Event est crée avec le changement et le temps, et on l'ajoute à la file des Event. Une fois, l'Event dans la file, les mutex sont libérés.

\subsection{Analogique}
La tâche pour l'acquisition des données analogique vérifie s'il y a un changement de la moyenne des 5 dernière lecture. La définition d'un changement est lorsque la nouvelle moyenne est $\pm$ 12.5$\%$ de l'ancienne moyenne. La lecture des pattes analogique opère à 50ms et envoi la moyenne recalculer au 250ms. Une boucle itérative sur 5 tours additionne les valeurs lu et attend 50ms. Une fois 5 échantillions additionné ensemble, soit 250ms plus tard, la comparaison est fait. Si une nouvelle valeur est accepté, une acquisition du mutex de la file des Event est appelé et le mutex du temps est acquis. un Event est crée et inséré dans le file. Ensuite les mutex sont relâchés. 

\subsection{L'horloge temps-réel (RTC)}

\section{Synchronisation des tâches CPU.}
Pour la scynchronisation des ressources et des tâches, des mutexs sont utilisé. Le code opère a l'aide d'une list de type FIFO.
\section{Déverminage.}
\section{Méthode de validation des fréquences d'échantillonage.}
\section{Analyse de performances des Codes de Métrologie Numérique.}
\section{Conclusion.}
\section{Schéma.}
\end{document}
